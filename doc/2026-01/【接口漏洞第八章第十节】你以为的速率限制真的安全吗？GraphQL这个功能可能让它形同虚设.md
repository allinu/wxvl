#  【接口漏洞第八章第十节】你以为的速率限制真的安全吗？GraphQL这个功能可能让它形同虚设  
原创 升斗安全XiuXiu
                    升斗安全XiuXiu  升斗安全   2026-01-31 13:01  
  
**【文章说明】**  
- **目的**  
：本文内容仅为网络安全**技术研究与教育**  
目的而创作。  
  
- **红线**  
：严禁将本文知识用于任何**未授权**  
的非法活动。使用者必须遵守《网络安全法》等相关法律。  
  
- **责任**  
：任何对本文技术的滥用所引发的**后果自负**  
，与本公众号及作者无关。  
  
- **免责**  
：内容仅供参考，作者不对其准确性、完整性作任何担保。  
  
**阅读即代表您同意以上条款。**  
  
****  
在前面章节中，分享了如何绕过  
GraphQL的自省防御，今天我们继续分享有关  
使用  
别名来  
绕过  
GraphQL的  
速率限制  
  
通常情况下，  
GraphQL 对象不能包含多个同名的属性。  
别名使你能够绕过这一限制，通过显式命名希望 API 返回的属性。利用  
别名，你可以在一次请求中返回同一类型的多个对象实例。  
  
有关   
GraphQL 别名的更多信息，可以看我前面分享的内容[【接口漏洞第八章第一节】挖洞前必修课：一文读懂GraphQL API核心概念](https://mp.weixin.qq.com/s?__biz=MjM5MzM0MTY4OQ==&mid=2447797764&idx=1&sn=da6733327b48ce9bb23c60e66c1b6583&scene=21#wechat_redirect)  
。  
  
虽然  
别名的设计初衷是为了减少需要进行的 API 调用次数，但它们也可  
用于对 GraphQL 端点进行暴力破解。  
  
许多端点都会设置某种  
速率限制器来  
防止暴力攻击。部分  
速率限制器是基于接收到的 HTTP 请求数量来工作，而非基于端点执行的操作数量。由于别名实际上允许你在单个 HTTP 消息中发送多个查询，因此可以绕过这一限制。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/VPUK6Jz75Q0r22akekNKOh1n9JABYQszQmeial1AZvX15s7s3XCXco8T5Awqic707MFyXBjuzPIXMBXstZQT5LwA/640?wx_fmt=png&from=appmsg "")  
  
如果对以上内容，不是很理解的话，可以继续看看以下内容，看是否对理解以上的技术原理有所帮助。  
  
引起漏洞的核心问题：  
传统速率限制的“盲点”  
  
很多网站的API为了防止黑客暴力猜测（比如猜密码、猜优惠码），会设置速率限制。比如：  
- 规则：1分钟最多只能尝试100次  
  
- 传统实现方式：服务器通过计算收到的HTTP请求的数量来执行这个规则。收到第101个请求时，就阻止或要求验证。  
  
  
GraphQL 的特性：  
“别名”  
  
GraphQL有一个功能叫 “别名” ，它原本是为了解决查询中字段命名冲突或需要多次查询同一类型数据而设计的。  
  
简单来说：它允许你在一个HTTP请求里，打包多个“问题”（查询）。  
  
攻击者如何利用这个特性？  
  
攻击者把原本需要发送N个HTTP请求才能完成的“暴力猜测”，  
合并成了1个HTTP请求。  
  
让我们用以下例子来解释：  
  
攻击目标：猜测一个有效的 discountCode（折扣码）。  
  
传统（RESTful API）攻击方式：  
- 攻击者发送请求1：检查  
code=123456 是否有效？  
  
- 发送请求2：检查  
code=888888 是否有效？  
  
- ...  
  
- 发送到第101个请求时，触发了速率限制，攻击被阻止。  
  
  
GraphQL（滥用别名）攻击方式：  
  
攻击者只发送1个HTTP请求，但这个请求的“正文”里，利用  
别名塞进了100个查询：  
```
graphql
query {
    # 这其实是一个查询，只是被问了100遍，每遍起了不同的名字（别名）
    check1: isValidDiscount(code: "123456") { valid }
    check2: isValidDiscount(code: "888888") { valid }
    check3: isValidDiscount(code: "111111") { valid }
    # ... 可以一直写到 check100 ...
}
```  
  
对服务器来说：它只收到了 1个 HTTP 请求，没有违反“1分钟100个请求”的规则。  
  
但实际效果：服务器后端需要执行这个GraphQL查询，它会依次处理   
check1,   
check2...   
check100  
【实际里面查询的参数都是  
code  
】，相当于在服务器内部进行了100次验证，并将结果一次性返回给攻击者。  
  
结果：攻击者在一次请求中就批量测试了100个折扣码，成功绕过了基于HTTP请求数的速率限制。  
  
就这样，通过利用 GraphQL 的  
别名功能，就可以实现对一些系统的漏洞利用。  
  
好了，今天的分享就先到这，明天这边会结合实际操作，给大家继续分享如何利用  
别名功能  
进行速率绕过，并实现漏洞挖掘。感兴趣的话，点点关注。  
  
觉得内容对你有用或无用，欢迎点赞或留言，这边会不断更正。  
  
